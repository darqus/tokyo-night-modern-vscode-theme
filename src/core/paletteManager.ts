/**
 * Менеджер палитр с поддержкой динамического управления, валидации и кэширования
 * Реализует интерфейс IPaletteManager
 */
import { basePalette } from './palette'
import { interfacePalette } from './interface'
import { syntaxPalette } from './syntax'
import { richSyntaxPalette } from './richSyntax'
import { getCachedColor, clearColorCache, getCacheStats } from './cache'
import type {
  InterfacePalette,
  SyntaxPalette,
  RichSyntaxPalette,
  Hex,
} from '../types/theme'
import type { ICacheManager } from './interfaces/ICacheManager'
import type { IPaletteManager } from './interfaces/IPaletteManager'

export class PaletteManager implements IPaletteManager {
  private currentInterfacePalette: InterfacePalette
  private currentSyntaxPalette: SyntaxPalette
  private currentRichSyntaxPalette: RichSyntaxPalette
  private validationErrors: string[] = []
  private config: Required<import('./interfaces/IPaletteManager').PaletteConfig>
  private cacheManager: ICacheManager

  constructor(
    cacheManager: ICacheManager,
    config: import('./interfaces/IPaletteManager').PaletteConfig = {}
  ) {
    this.cacheManager = cacheManager
    this.config = {
      enableValidation: config.enableValidation ?? true,
      strictMode: config.strictMode ?? false,
      autoGenerateDerived: config.autoGenerateDerived ?? true,
      optimizeOnUpdate: config.optimizeOnUpdate ?? true,
    }

    // Инициализация палитр
    this.currentInterfacePalette = { ...interfacePalette }
    this.currentSyntaxPalette = { ...syntaxPalette }
    this.currentRichSyntaxPalette = { ...richSyntaxPalette }

    // Генерация производных цветов при инициализации
    if (this.config.autoGenerateDerived) {
      this.generateDerivedColors()
    }
  }

  // Доступ к палитрам
  getInterfacePalette(): InterfacePalette {
    const cacheKey = 'interface-palette'
    const cached = this.cacheManager.get<InterfacePalette>(cacheKey)
    if (cached) {
      return cached
    }

    const palette = { ...this.currentInterfacePalette }
    this.cacheManager.set(cacheKey, palette)
    return palette
  }

  getSyntaxPalette(): SyntaxPalette {
    const cacheKey = 'syntax-palette'
    const cached = this.cacheManager.get<SyntaxPalette>(cacheKey)
    if (cached) {
      return cached
    }

    const palette = { ...this.currentSyntaxPalette }
    this.cacheManager.set(cacheKey, palette)
    return palette
  }

  getRichSyntaxPalette(): RichSyntaxPalette {
    const cacheKey = 'rich-syntax-palette'
    const cached = this.cacheManager.get<RichSyntaxPalette>(cacheKey)
    if (cached) {
      return cached
    }

    const palette = { ...this.currentRichSyntaxPalette }
    this.cacheManager.set(cacheKey, palette)
    return palette
  }

  // Модификация палитр
  updateInterfacePalette(updates: Partial<InterfacePalette>): void {
    this.currentInterfacePalette = this.deepMerge(
      this.currentInterfacePalette,
      updates
    )

    // Очистка кэша
    this.cacheManager.delete('interface-palette')

    // Валидация
    if (this.config.enableValidation) {
      this.validatePalette(this.currentInterfacePalette)
    }

    // Оптимизация
    if (this.config.optimizeOnUpdate) {
      this.optimizeForAccessibility()
    }

    // Генерация производных цветов
    if (this.config.autoGenerateDerived) {
      this.generateDerivedColors()
    }
  }

  updateSyntaxPalette(updates: Partial<SyntaxPalette>): void {
    this.currentSyntaxPalette = { ...this.currentSyntaxPalette, ...updates }

    // Очистка кэша
    this.cacheManager.delete('syntax-palette')

    // Валидация
    if (this.config.enableValidation) {
      this.validatePalette(this.currentSyntaxPalette)
    }
  }

  updateRichSyntaxPalette(updates: Partial<RichSyntaxPalette>): void {
    this.currentRichSyntaxPalette = this.deepMerge(
      this.currentRichSyntaxPalette,
      updates
    )

    // Очистка кэша
    this.cacheManager.delete('rich-syntax-palette')

    // Валидация
    if (this.config.enableValidation) {
      this.validatePalette(this.currentRichSyntaxPalette)
    }
  }

  // Валидация
  validatePalette(
    palette: Partial<InterfacePalette | SyntaxPalette | RichSyntaxPalette>
  ): boolean {
    this.validationErrors = []

    try {
      this.validateHexColors(palette)
      this.validateContrastRequirements(palette)
      this.validatePaletteStructure(palette)
    } catch (error) {
      this.validationErrors.push(
        `Validation error: ${
          error instanceof Error ? error.message : String(error)
        }`
      )
    }

    if (this.config.strictMode && this.validationErrors.length > 0) {
      throw new Error(
        `Palette validation failed: ${this.validationErrors.join(', ')}`
      )
    }

    return this.validationErrors.length === 0
  }

  getValidationErrors(): string[] {
    return [...this.validationErrors]
  }

  // Экспорт/импорт
  exportPalette(): string {
    const exportData = {
      interface: this.currentInterfacePalette,
      syntax: this.currentSyntaxPalette,
      richSyntax: this.currentRichSyntaxPalette,
      config: this.config,
      timestamp: new Date().toISOString(),
    }

    return JSON.stringify(exportData, null, 2)
  }

  importPalette(data: string): boolean {
    try {
      const imported = JSON.parse(data)

      // Валидация структуры
      if (!imported.interface || !imported.syntax || !imported.richSyntax) {
        throw new Error('Invalid palette data structure')
      }

      // Валидация перед применением
      if (this.config.enableValidation) {
        this.validatePalette(imported.interface)
        this.validatePalette(imported.syntax)
        this.validatePalette(imported.richSyntax)
      }

      // Применение импортированных палитр
      this.currentInterfacePalette = imported.interface
      this.currentSyntaxPalette = imported.syntax
      this.currentRichSyntaxPalette = imported.richSyntax

      // Очистка кэша
      this.cacheManager.clear()
      this.cacheManager.set('interface-palette', this.currentInterfacePalette)
      this.cacheManager.set('syntax-palette', this.currentSyntaxPalette)
      this.cacheManager.set(
        'rich-syntax-palette',
        this.currentRichSyntaxPalette
      )

      // Применение конфигурации
      if (imported.config) {
        this.config = { ...this.config, ...imported.config }
      }

      return true
    } catch (error) {
      this.validationErrors.push(
        `Import error: ${
          error instanceof Error ? error.message : String(error)
        }`
      )
      return false
    }
  }

  // Генерация производных цветов
  generateDerivedColors(): void {
    // Генерация дополнительных текстовых ролей для surface-aware дизайна
    this.generateSurfaceAwareTextColors()

    // Генерация дополнительных состояний для интерактивных элементов
    this.generateInteractiveStates()

    // Генерация дополнительных производных цветов для улучшения доступности
    this.generateAccessibilityColors()

    // Очистка кэша после генерации
    this.cacheManager.delete('interface-palette')
  }

  // Оптимизация для доступности
  optimizeForAccessibility(): void {
    const interfacePalette = this.currentInterfacePalette

    // Проверка и оптимизация контрастности для основных пар
    this.optimizeTextContrast(
      interfacePalette.bg.base,
      interfacePalette.text.primary
    )
    this.optimizeTextContrast(
      interfacePalette.bg.elevated,
      interfacePalette.text.primary
    )
    this.optimizeTextContrast(
      interfacePalette.bg.overlay,
      interfacePalette.text.primary
    )

    // Оптимизация цветов состояний
    this.optimizeStateColors(interfacePalette.state)

    // Очистка кэша после оптимизации
    this.cacheManager.delete('interface-palette')
  }

  // Приватные методы для валидации

  private validateHexColors(
    palette: Partial<InterfacePalette | SyntaxPalette | RichSyntaxPalette>
  ): void {
    const hexRegex = /^#[0-9A-F]{6}$/i

    const validateObject = (obj: any, path: string = ''): void => {
      for (const [key, value] of Object.entries(obj)) {
        const currentPath = path ? `${path}.${key}` : key

        if (typeof value === 'string') {
          if (!hexRegex.test(value)) {
            this.validationErrors.push(
              `Invalid hex color at ${currentPath}: ${value}`
            )
          }
        } else if (typeof value === 'object' && value !== null) {
          validateObject(value, currentPath)
        }
      }
    }

    validateObject(palette)
  }

  private validateContrastRequirements(
    palette: Partial<InterfacePalette | SyntaxPalette | RichSyntaxPalette>
  ): void {
    // Базовая проверка контрастности для основных текстовых пар
    if ('bg' in palette && 'text' in palette) {
      const bg = (palette as any).bg?.base
      const text = (palette as any).text?.primary

      if (bg && text) {
        const contrast = this.calculateContrast(bg, text)
        if (contrast < 4.5) {
          this.validationErrors.push(
            `Insufficient contrast ratio (${contrast.toFixed(
              2
            )}) between background and text`
          )
        }
      }
    }
  }

  private validatePaletteStructure(
    palette: Partial<InterfacePalette | SyntaxPalette | RichSyntaxPalette>
  ): void {
    // Проверка наличия обязательных полей
    if ('bg' in palette && palette.bg) {
      const requiredBgFields = ['base', 'elevated', 'overlay']
      for (const field of requiredBgFields) {
        if (!(field in (palette as any).bg)) {
          this.validationErrors.push(`Missing required field bg.${field}`)
        }
      }
    }

    if ('text' in palette && palette.text) {
      const requiredTextFields = ['primary', 'muted', 'subtle']
      for (const field of requiredTextFields) {
        if (!(field in (palette as any).text)) {
          this.validationErrors.push(`Missing required field text.${field}`)
        }
      }
    }
  }

  // Приватные методы для генерации производных цветов

  private generateSurfaceAwareTextColors(): void {
    const palette = this.currentInterfacePalette

    // Генерация дополнительных текстовых цветов для разных поверхностей
    if (!palette.textOn.elevated) {
      palette.textOn.elevated = {
        primary: this.adjustColorForSurface(
          palette.text.primary,
          palette.bg.elevated
        ),
        muted: this.adjustColorForSurface(
          palette.text.muted,
          palette.bg.elevated
        ),
        subtle: this.adjustColorForSurface(
          palette.text.subtle,
          palette.bg.elevated
        ),
        inactive: this.adjustColorForSurface(
          palette.text.inactive,
          palette.bg.elevated
        ),
      }
    }

    if (!palette.textOn.overlay) {
      palette.textOn.overlay = {
        primary: this.adjustColorForSurface(
          palette.text.primary,
          palette.bg.overlay
        ),
        muted: this.adjustColorForSurface(
          palette.text.muted,
          palette.bg.overlay
        ),
        subtle: this.adjustColorForSurface(
          palette.text.subtle,
          palette.bg.overlay
        ),
        inactive: this.adjustColorForSurface(
          palette.text.inactive,
          palette.bg.overlay
        ),
      }
    }
  }

  private generateInteractiveStates(): void {
    const palette = this.currentInterfacePalette

    // Генерация дополнительных состояний для кнопок
    if (!palette.button.primary.hoverBackground) {
      palette.button.primary.hoverBackground = this.lightenColor(
        palette.button.primary.background,
        0.1
      )
    }

    if (!palette.button.secondary.hoverBackground) {
      palette.button.secondary.hoverBackground = this.lightenColor(
        palette.button.secondary.background,
        0.1
      )
    }

    // Генерация дополнительных состояний для состояний
    if (!palette.state.infoHover) {
      palette.state.infoHover = this.lightenColor(palette.state.info, 0.1)
    }

    if (!palette.state.successHover) {
      palette.state.successHover = this.lightenColor(palette.state.success, 0.1)
    }

    if (!palette.state.warningHover) {
      palette.state.warningHover = this.lightenColor(palette.state.warning, 0.1)
    }

    if (!palette.state.errorHover) {
      palette.state.errorHover = this.lightenColor(palette.state.error, 0.1)
    }
  }

  private generateAccessibilityColors(): void {
    const palette = this.currentInterfacePalette

    // Генерация дополнительных цветов для улучшения доступности
    if (!palette.derived) {
      palette.derived = {
        link: { foreground: palette.text.primary },
        terminal: this.generateTerminalColors(),
        overlays: { dropBackground: palette.bg.overlay },
        findMatch: this.generateFindMatchColors(),
        shadows: this.generateShadowColors(),
        peekView: this.generatePeekViewColors(),
        inlineChat: this.generateInlineChatColors(),
        blockquote: this.generateBlockquoteColors(),
      }
    }
  }

  // Приватные вспомогательные методы

  private deepMerge<T extends object>(target: T, source: Partial<T>): T {
    const result = { ...target }

    for (const key in source) {
      if (
        source[key] &&
        typeof source[key] === 'object' &&
        !Array.isArray(source[key])
      ) {
        result[key] = this.deepMerge(
          (result as any)[key] || {},
          source[key] as any
        )
      } else {
        result[key] = source[key] as any
      }
    }

    return result
  }

  private calculateContrast(color1: Hex, color2: Hex): number {
    // Упрощенный расчет контрастности (WCAG)
    const rgb1 = this.hexToRgb(color1)
    const rgb2 = this.hexToRgb(color2)

    const l1 = this.calculateLuminance(rgb1)
    const l2 = this.calculateLuminance(rgb2)

    const lighter = Math.max(l1, l2)
    const darker = Math.min(l1, l2)

    return (lighter + 0.05) / (darker + 0.05)
  }

  private hexToRgb(hex: Hex): { r: number; g: number; b: number } {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)
    return result
      ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16),
        }
      : { r: 0, g: 0, b: 0 }
  }

  private calculateLuminance(rgb: { r: number; g: number; b: number }): number {
    const { r, g, b } = rgb
    const [rs, gs, bs] = [r, g, b].map((c) => {
      c = c / 255
      return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4)
    })
    return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs
  }

  private adjustColorForSurface(color: Hex, surface: Hex): Hex {
    // Корректировка цвета для лучшей читаемости на поверхности
    const contrast = this.calculateContrast(color, surface)

    if (contrast < 4.5) {
      // Если контраст недостаточный, осветляем или затемняем цвет
      const surfaceLuminance = this.calculateLuminance(this.hexToRgb(surface))
      const colorLuminance = this.calculateLuminance(this.hexToRgb(color))

      if (surfaceLuminance > 0.5) {
        return this.darkenColor(color, 0.2)
      } else {
        return this.lightenColor(color, 0.2)
      }
    }

    return color
  }

  private optimizeTextContrast(background: Hex, foreground: Hex): void {
    const contrast = this.calculateContrast(background, foreground)

    if (contrast < 4.5) {
      // Попытка оптимизировать контраст
      const bgLuminance = this.calculateLuminance(this.hexToRgb(background))

      if (bgLuminance > 0.5) {
        // Для светлого фона делаем текст темнее
        this.adjustTextColor(foreground, -0.3)
      } else {
        // Для темного фона делаем текст светлее
        this.adjustTextColor(foreground, 0.3)
      }
    }
  }

  private optimizeStateColors(states: any): void {
    // Оптимизация контрастности для состояний
    const statePairs = [
      { state: states.info, bg: this.currentInterfacePalette.bg.base },
      { state: states.success, bg: this.currentInterfacePalette.bg.base },
      { state: states.warning, bg: this.currentInterfacePalette.bg.base },
      { state: states.error, bg: this.currentInterfacePalette.bg.base },
    ]

    for (const pair of statePairs) {
      this.optimizeTextContrast(pair.bg, pair.state)
    }
  }

  private lightenColor(color: Hex, amount: number): Hex {
    const rgb = this.hexToRgb(color)
    const [r, g, b] = [rgb.r, rgb.g, rgb.b].map((c) =>
      Math.min(255, Math.floor(c + (255 - c) * amount))
    )
    return this.rgbToHex(r, g, b)
  }

  private darkenColor(color: Hex, amount: number): Hex {
    const rgb = this.hexToRgb(color)
    const [r, g, b] = [rgb.r, rgb.g, rgb.b].map((c) =>
      Math.max(0, Math.floor(c * (1 - amount)))
    )
    return this.rgbToHex(r, g, b)
  }

  private adjustTextColor(color: Hex, amount: number): void {
    // Находим и изменяем цвет в палитре
    // Это упрощенная реализация - в реальном коде нужно искать конкретное поле
    const rgb = this.hexToRgb(color)
    const [r, g, b] = [rgb.r, rgb.g, rgb.b].map((c) =>
      Math.max(0, Math.min(255, Math.floor(c + amount * 255)))
    )
  }

  private rgbToHex(r: number, g: number, b: number): Hex {
    return `#${((1 << 24) + (r << 16) + (g << 8) + b)
      .toString(16)
      .slice(1)}` as Hex
  }

  // Генераторы конкретных групп цветов
  private generateTerminalColors(): any {
    return {
      ansiBlack: basePalette.black,
      ansiRed: basePalette.red,
      ansiGreen: basePalette.green,
      ansiYellow: basePalette.yellow,
      ansiMagenta: basePalette.magenta,
      ansiWhite: this.lightenColor(basePalette.black, 0.4),
      hoverHighlightBackground: this.lightenColor(basePalette.blue, 0.1),
      ansiBlue: basePalette.blue,
      ansiCyan: basePalette.cyan,
      ansiBrightBlack: this.lightenColor(basePalette.black, 0.4),
      ansiBrightRed: this.lightenColor(basePalette.red, 0.15),
      ansiBrightGreen: this.lightenColor(basePalette.green, 0.15),
      ansiBrightYellow: this.lightenColor(basePalette.yellow, 0.15),
      ansiBrightBlue: this.lightenColor(basePalette.blue, 0.15),
      ansiBrightMagenta: this.lightenColor(basePalette.magenta, 0.15),
      ansiBrightCyan: this.lightenColor(basePalette.cyan, 0.15),
      ansiBrightWhite: this.lightenColor(basePalette.black, 0.8),
    }
  }

  private generateFindMatchColors(): any {
    return {
      background: this.lightenColor(basePalette.blue, 0.2),
      border: basePalette.blue,
      highlightBackground: this.lightenColor(basePalette.blue, 0.1),
    }
  }

  private generateShadowColors(): any {
    return {
      widget: this.darkenColor(basePalette.black, 0.2),
      scrollbar: this.darkenColor(basePalette.black, 0.1),
    }
  }

  private generatePeekViewColors(): any {
    return {
      matchHighlightBackground: this.lightenColor(basePalette.blue, 0.15),
      selectionBackground: this.lightenColor(basePalette.blue, 0.2),
    }
  }

  private generateInlineChatColors(): any {
    return {
      background: this.darkenColor(basePalette.blue, 0.3),
      foreground: this.lightenColor(basePalette.textPrimary, 0.1),
    }
  }

  private generateBlockquoteColors(): any {
    return {
      background: this.darkenColor(basePalette.surfaceOverlay, 0.1),
      border: this.lightenColor(basePalette.cyan, 0.2),
    }
  }
}
